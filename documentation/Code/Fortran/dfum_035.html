<!-- DFUM_035.HTML continuation of C4$:[SAVAGE.HTML.UM]DFUM.HTML -->
<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>DIGITAL Fortran 90</title>
</head>
<body bgcolor="white">
<font color="maroon">
<h1 align="center">DIGITAL Fortran 90<br>User Manual for <br> DIGITAL UNIX Systems</h1>
</font>

<hr>
<table border="2">
  <tbody><tr>
    <td align="center" bgcolor="lightgoldenrodyellow" width="100"><a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#bottom_034">Previous</a>
    </td><td align="center" bgcolor="cyan" width="100"><a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_contents.html">Contents</a>
    </td><td align="center" bgcolor="lightskyblue" width="100"><a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_index.html">Index</a>
</td></tr></tbody></table>

<hr>

<a name="sec_complex16"><h2>9.4.6 COMPLEX (KIND=8) or COMPLEX*16 Representation</h2></a>
<a name="index_x_2968"></a>

<p>
Intrinsic COMPLEX (KIND=8) or COMPLEX*16 (same as DOUBLE COMPLEX) data 
is 16 contiguous bytes containing a pair of REAL*8 values stored in 
IEEE T_float format.

</p><p>
The low-order eight bytes contain REAL (KIND=8) data that represents 
the real part of the complex data. The high-order eight bytes contain 
REAL (KIND=8) data that represents the imaginary part of the complex 
data, as shown in <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_035.html#fig_complex_16">Figure 9-10</a>.
<a name="fig_complex_16"></a>
</p><p>
<strong>Figure 9-10 COMPLEX (KIND =8) or COMPLEX*16 
Representation</strong>
</p><hr>
<img src="dfum_035-Dateien/zk-9818.gif">

<p>
The limits and underflow characteristics for REAL (KIND=8) apply to the 
two separate real and imaginary parts of a COMPLEX (KIND=8) or 
COMPLEX*16 number. Like REAL (KIND=8) or REAL*8 numbers, the sign bit 
representation is 0 (zero) for positive numbers and 1 for negative 
numbers.
</p><p>
<strong>For More Information:</strong>
<br>

</p><ul>
  <li>On converting unformatted data, see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_035.html#ch_conv">Chapter 10</a>.
  </li><li>On defining constants and assigning values to variables, see the 
  <em>DIGITAL Fortran Language Reference Manual</em>.
  </li><li>On intrinsic functions related to the various data types, such as 
  SELECTED_REAL_KIND, see the <em>DIGITAL Fortran Language Reference Manual</em>.
  </li><li>On VAX (OpenVMS) floating-point data types (provided for those 
  converting OpenVMS data), see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_044.html#sec_fltng_pt_vax">Section A.4.3</a>.
  </li><li>On the
<font size="+1"><tt>f90</tt></font>
 command options that control the size of REAL and COMPLEX declarations 
 (without a kind parameter or size specifier), see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_011.html#sec_option_real">Section 3.63</a>.
  </li><li>On the
<font size="+1"><tt>f90</tt></font>
 command options that control the size of DOUBLE PRECISION declarations, 
 see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_008.html#sec_option_double">Section 3.25</a>.
  </li><li>On IEEE binary floating-point, see ANSI/IEEE Standard 754-1985.
</li></ul>

<a name="sec_fltng_pt_exc"><h2>9.4.7 Exceptional Floating-Point Representations</h2></a>
<a name="index_x_2969"></a>
<a name="index_x_2970"></a>
<a name="index_x_2971"></a>
<a name="index_x_2972"></a>

<p>
<strong>Exceptional values</strong> usually result from a computation 
and include plus infinity, minus infinity, NaN, and denormalized 
numbers.

</p><p>
Floating-point numbers can be one of the following:

</p><ul>
  <li><strong>Alpha finite number</strong>---A floating-point number that 
  represents a valid number (bit pattern) within the normalized ranges of 
  a particular data type, including --<em>max</em> to 
  --<em>min</em>,---zero, +zero, +<em>min</em> to +<em>max</em>. <br>For 
  any native IEEE floating-point data type, the values of <em>min</em> or 
  <em>max</em> are listed in <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_real4">Section 9.4.2</a> (single precision), 
  <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_real8">Section 9.4.3</a> (double precision), and <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_real16_x">Section 9.4.4</a> (extended 
  precision). <br>Special bit patterns that are <em>not</em> Alpha finite 
  numbers represent exceptional values.
  </li><li><strong>Infinity</strong>---An IEEE floating-point bit pattern
<a name="index_x_2973"></a>
<a name="index_x_2974"></a>
<a name="index_x_2975"></a>
that represents plus or minus infinity. DIGITAL Fortran 90 identifies 
infinity values with the letters "Infinity" or asterisks 
(******) in output statements (depends on field width) or certain 
hexadecimal values (fraction of 0 and exponent of all 1 values).
  </li><li><strong>Not-a-Number (NaN)</strong>---An IEEE floating-point bit 
  pattern that
<a name="index_x_2976"></a>
<a name="index_x_2977"></a>
<a name="index_x_2978"></a>
represents something other than a number. DIGITAL Fortran 90 identifies NaN 
values with the letters "NaN" in output statements. A NaN can 
be a signaling NaN or a quiet NaN:

  <ul>
    <li>A quiet NaN might occur as a result of a calculation, such as 0./0. 
    and has an exponent of all 1 values and initial fraction bit of 1.
    </li><li>A signaling NaN must be set intentionally (does not result from 
    calculations) and has an exponent of all 1 values and initial fraction 
    bit of 0 (with one or more other fraction bits of 1).
  </li></ul>
  </li><li><strong>Denormal</strong>---Identifies an IEEE floating-point bit 
  pattern
<a name="index_x_2979"></a>
<a name="index_x_2980"></a>
<a name="index_x_2981"></a>
<a name="index_x_2982"></a>
that represents a number whose value falls between zero and the 
smallest finite (normalized) number for that data type. The exponent 
field contains all zeros. <br>For negative numbers, denormalized 
numbers range from the next representable value larger than minus zero 
to the representable value that is one bit less than the smallest 
finite (normalized) negative number. For positive numbers, denormalized 
numbers range from the next representable value larger than positive 
zero to the representable value that is one bit less than the smallest 
finite (normalized) positive number.
<a name="index_x_2983"></a>
<a name="index_x_2984"></a>
<a name="index_x_2985"></a>
  </li><li><strong>Zero</strong>---Can be the value +0 (all zero bits, also 
  called true zero)
<a name="index_x_2986"></a>
or -0 (all zero bits except the sign bit, such as Z<font size="+1"><tt>'</tt></font>8000000000000000<font size="+1"><tt>'</tt></font>).
</li></ul>

<p>
A NaN or infinity value might result from a calculation that contains a 
divide by zero, overflow, or invalid data.

</p><p>
A denormalized number occurs when the result of a calculation falls 
within the denormalized range for that data type (subnormal value).

</p><p>
To control floating-point exception handling at run time for the main 
program, use the appropriate
<font size="+1"><tt>-fpe<em>n</em></tt></font>
 option. The callable
<font size="+1"><tt>for_set_fpe</tt></font>
 routine allows further control for subprogram use or conditional use 
 during program execution.

</p><p>
If an exceptional value is used in a calculation, an unrecoverable 
exception can occur unless you specify the appropriate
<font size="+1"><tt>-fpe<em>n</em></tt></font>
 option or use the
<font size="+1"><tt>for_set_fpe</tt></font>
 routine. Denormalized numbers can be processed as is, set equal to zero 
 with program continuation or a program stop, and generate warning 
 messages (see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_008.html#sec_option_fpe">Section 3.33</a>).

</p><p>
<a name="index_x_2987"></a>
<a name="index_x_2988"></a>
<a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_035.html#tab_except">Table 9-2</a> lists the hexadecimal (hex) values of the IEEE 
exceptional floating-point numbers in Alpha systems, for S_float 
(single precision), T_float (double precision), and X_float (extended 
precision) formats: </p><p>

<table border="3">
  <caption><a name="tab_except"><strong>Table 9-2 Exceptional Floating-Point Numbers</strong></a></caption>
  <tbody><tr bgcolor="lightseagreen">
    <th align="center">Exceptional Number </th>
    <th align="center">Hex Value </th>
  </tr>
  <tr bgcolor="lightseagreen">
    <th colspan="2" align="left">S_float Representation </th>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Infinity (+)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
7F800000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Infinity (--)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
FF800000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Zero (+0)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
00000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Zero (--0)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
80000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Quiet NaN (+)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
7FC00000
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
7FFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Quiet NaN (--)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
FFC00000
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
FFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Signaling NaN (+)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
7F800001
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
7FBFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Signaling NaN (--)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
FF800001
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
FFBFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="lightseagreen">
    <th colspan="2" align="left">T_float Representation </th>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Infinity (+)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
7FF0000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Infinity (--)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
FFF0000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Zero (+0)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
0000000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Zero (-0)
    </td>
    <td>
Z
<font size="+1">
<tt>'</tt>
</font>
8000000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Quiet NaN (+)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
7FF8000000000000
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
7FFFFFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Quiet NaN (--)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
FFF8000000000000
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
FFFFFFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Signaling NaN (+)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
7FF0000000000001
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
7FF7FFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Signaling NaN (--)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
FFF0000000000001
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
FFF7FFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="lightseagreen">
    <th colspan="2" align="left">X_float Representation </th>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Infinity (+)
    </td>
    <td>
 Z
<font size="+1">
<tt>'</tt>
</font>
7FFF0000000000000000000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Infinity (--)
    </td>
    <td>
 Z
<font size="+1">
<tt>'</tt>
</font>
FFFF0000000000000000000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Zero (+0)
    </td>
    <td>
 Z
<font size="+1">
<tt>'</tt>
</font>
000000000000000000000000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Zero (--0)
    </td>
    <td>
 Z
<font size="+1">
<tt>'</tt>
</font>
800000000000000000000000000000000
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Quiet NaN (+)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
7FFF80000000000000000000000000000
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Quiet NaN (--)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
FFFF80000000000000000000000000000
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Signaling NaN (+)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
7FFF00000000000000000000000000001
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
7FFF7FFFFFFFFFFFFFFFFFFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      Signaling NaN (--)
    </td>
    <td>
From Z
<font size="+1">
<tt>'</tt>
</font>
FFFF00000000000000000000000000001
<font size="+1">
<tt>'</tt>
</font>
 to Z
<font size="+1">
<tt>'</tt>
</font>
FFFF7FFFFFFFFFFFFFFFFFFFFFFFFFFFF
<font size="+1">
<tt>'</tt>
</font>
    </td>
  </tr>
</tbody></table>

</p><p>
DIGITAL Fortran 90 supports IEEE exception handling, allowing you to test 
for infinity by using a comparison of floating-point data (such as 
generating positive infinity by using a calculation like x=1.0/0 and 
comparing x to the calculated number).

</p><p>
The appropriate
<font size="+1"><tt>f90</tt></font>
 command
<font size="+1"><tt>-fpe<em>n</em></tt></font>
 options or calling the
<font size="+1"><tt>for_set_fpe</tt></font>
 routine with appropriate arguments allows program continuation when a 
 calculation results in a divide by zero, overflow, or invalid data 
 arithmetic exception, generating an exceptional value (a NaN or 
 Infinity (+ or --)).

</p><p>
<a name="index_x_2989"></a>
<a name="index_x_2990"></a>
<a name="index_x_2991"></a>
To test for a NaN when DIGITAL Fortran 90 allows continuation for 
arithmetic exceptions, you can use the ISNAN intrinsic function.

</p><p>
For example, you might use the following code to test a DOUBLE 
PRECISION (REAL (KIND=8)) value:
<a name="index_x_2992"></a>

</p><p>
<table border="0">
  <tbody><tr>
    <td bgcolor="blanchedalmond">
      <br>
      <font color="mediumblue"><pre>      DOUBLE PRECISION A, B, F 
      A = 0. 
      B = 0. 
 
!     Perform calculations with variables A and B 
      . 
      . 
      . 
 
!     f contains the value to check against a particular NaN 
 
      F = A / B 
 
      IF (ISNAN(F)) THEN 
         WRITE (6,*) '--&gt; Variable F contains a NaN value &lt;--' 
      ENDIF 
 
!     Inform user that f has the hardware quiet NaN value 
 
!     Perform calculations with variable F (or stop program early) 
 
      END PROGRAM 
</pre>
</font>
</td></tr></tbody></table>

</p><p>
<a name="index_x_2993"></a>
<a name="index_x_2994"></a>
<a name="index_x_2995"></a>
This program might be compiled with
<font size="+1"><tt>-fpe2</tt></font>
 or
<font size="+1"><tt>-fpe4</tt></font>
 to allow:

</p><ul>
  <li>Continuation when a NaN (or other exceptional value) is encountered 
  in a calculation
  </li><li>A summary message explaining the number and types of arithmetic 
  exceptions encountered:

<p>
<table border="0">
  <tbody><tr>
    <td bgcolor="blanchedalmond">
      <br>
      <font color="mediumblue"><pre>% <strong>f90 -fpe2 isnan.for</strong>
% <strong>a.out</strong>
forrtl: error: floating invalid 
 --&gt; Variable F contains a NaN value &lt;-- 
forrtl: info: 1 floating invalid traps
</pre>
</font>
</td></tr></tbody></table>

</p></li></ul>

<p>
The FP_CLASS intrinsic function is also available to check for 
exceptional values (see the <em>DIGITAL Fortran Language Reference Manual</em> and the file
<font size="+1"><tt>/usr/include/fordef.f</tt></font>
).
</p><p>
<strong>For More Information:</strong>
<br>

</p><ul>
  <li>On using the
<font size="+1"><tt>f90</tt></font>
 command
<font size="+1"><tt>-fpe<em>n</em></tt></font>
 options and the
<font size="+1"><tt>for_set_fpe</tt></font>
 routine to control arithmetic exception handling, see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_008.html#sec_option_fpe">Section 3.33</a>.
  </li><li>On Alpha exceptional values, see <em>Alpha Architecture Reference Manual</em>.
  </li><li>On IEEE binary floating-point exception handling, see the <em>IEEE 
  Standard for Binary Floating-Point Arithmetic</em> (ANSI/IEEE Standard 
  754-1985) and <font size="+1"><tt>ieee(3)</tt></font>.
</li></ul>

<a name="sec_char_rep"><h1><font color="maroon">9.5 Character Representation</font></h1></a>
<a name="index_x_2996"></a>
<a name="index_x_2997"></a>

<p>
A character string is a contiguous sequence of bytes in memory, as 
shown in <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_035.html#fig_character">Figure 9-11</a>.
<a name="fig_character"></a>
</p><p>
<strong>Figure 9-11 CHARACTER Data Representation</strong>
</p><hr>
<img src="dfum_035-Dateien/zk-0809.gif">

<p>
A character string is specified by two attributes: the address A of the 
first byte of the string, and the length L of the string in bytes. The 
length L of a string is in the range 1 through 65,535.
</p><p>
<strong>For More Information:</strong>
<br>

</p><ul>
  <li>On defining constants, assigning values to variables, using 
  substring expressions, and concatenation, see the <em>DIGITAL Fortran Language Reference Manual</em>.
  </li><li>On intrinsic functions related to the various data types, see the 
  <em>DIGITAL Fortran Language Reference Manual</em>.
</li></ul>

<a name="sec_holrith_rep"><h1><font color="maroon">9.6 Hollerith Representation</font></h1></a>
<a name="index_x_2998"></a>
<a name="index_x_2999"></a>

<p>
Hollerith constants are stored internally, one character per byte. When 
Hollerith constants contain the ASCII representation of characters, 
they resemble the storage of character data (see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_035.html#fig_character">Figure 9-11</a>).

</p><p>
When Hollerith constants store numeric data, they usually have a length 
of one, two, four, or eight bytes and resemble the corresponding 
numeric data type.
</p><p>
<strong>For More Information:</strong>
<br>

</p><ul>
  <li>On defining constants and assigning values to variables, see the 
  <em>DIGITAL Fortran Language Reference Manual</em>.
  </li><li>On intrinsic functions related to the various data types, see the 
  <em>DIGITAL Fortran Language Reference Manual</em>.
</li></ul>

<p>
</p><hr size="5">
<font color="maroon">
<a name="ch_conv"><h1>Chapter 10<br>Converting Unformatted Numeric Data</h1></a>
</font>

<p>
This chapter describes how you can use DIGITAL Fortran 90 to read and write 
unformatted numeric data in certain nonnative formats, including big 
endian IEEE and VAX floating-point formats.

</p><p>
On DIGITAL UNIX systems, DIGITAL Fortran 90 supports the following little 
endian floating-point formats in memory:

<table border="3">
  <tbody><tr bgcolor="lightseagreen">
    <th align="center">Floating-Point Size </th>
    <th align="center">Format in Memory </th>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      KIND=4
    </td>
    <td>
      IEEE S_float
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      KIND=8
    </td>
    <td>
      IEEE T_float
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      KIND=16
    </td>
    <td>
      DIGITAL IEEE style X_float
    </td>
  </tr>
</tbody></table>

</p><p>
If your program needs to read or write unformatted data files 
containing a floating-point format that differs from the format in 
memory for that data size, you can request that the unformatted data be 
converted.

</p><p>
Converting unformatted data is generally faster than converting 
formatted data and is less likely to lose precision for floating-point 
numbers.

<a name="sec_float_convert_endian"></a></p><h1><a name="sec_float_convert_endian"><font color="maroon">10.1 Endian Order of Numeric Formats</font></a></h1>

<p>
<a name="index_x_3000"></a>
<a name="index_x_3001"></a>
<a name="index_x_3002"></a>
<a name="index_x_3003"></a>
<a name="index_x_3004"></a>
<a name="index_x_3005"></a>
<a name="index_x_3006"></a>
<a name="index_x_3007"></a>
<a name="index_x_3008"></a>
<a name="index_x_3009"></a>
<a name="index_x_3010"></a>
<a name="index_x_3011"></a>
<a name="index_x_3012"></a>
Data storage in different computers use a convention of either 
<strong>little endian</strong> or <strong>big endian</strong> storage. 
The storage convention generally applies to numeric values that span 
multiple bytes, as follows:

</p><ul>
  <li><strong>Little endian</strong> storage occurs when:

  <ul>
    <li>The least significant bit (LSB) value is in the byte with the 
    lowest address.
    </li><li>The most significant bit (MSB) value is in the byte with the 
    highest address.
    </li><li>The address of the numeric value is the byte containing the LSB. 
    Subsequent bytes with higher addresses contain more significant bits.
  </li></ul>
  </li><li><strong>Big endian</strong> storage occurs when:

  <ul>
    <li>The least significant bit (LSB) value is in the byte with the 
    highest address.
    </li><li>The most significant bit (MSB) value is in the byte with the lowest 
    address.
    </li><li>The address of the numeric value is the byte containing the MSB. 
    Subsequent bytes with higher addresses contain less significant bits.
  </li></ul>
</li></ul>

<p>
<a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_035.html#fig_endian">Figure 10-1</a> shows the difference between the two byte-ordering 
schemes.
<a name="fig_endian"></a>
</p><p>
<strong>Figure 10-1 Little and Big Endian Storage of an INTEGER 
Value</strong>
</p><hr>
<img src="dfum_035-Dateien/zk-6654a.gif">

<p>
Moving data files between big endian and little endian computers 
requires that the data be converted.

<a name="sec_float_convert"></a></p><h1><a name="sec_float_convert"><font color="maroon">10.2 Native and Supported Nonnative Numeric Formats</font></a></h1>

<p>
<a name="index_x_3013"></a>
<a name="index_x_3014"></a>
<a name="index_x_3015"></a>
<a name="index_x_3016"></a>
<a name="index_x_3017"></a>
<a name="index_x_3018"></a>
<a name="index_x_3019"></a>
<a name="index_x_3020"></a>
<a name="index_x_3021"></a>
<a name="index_x_3022"></a>
<a name="index_x_3023"></a>
<a name="index_x_3024"></a>
<a name="index_x_3025"></a>
<a name="index_x_3026"></a>
<a name="index_x_3027"></a>
<a name="index_x_3028"></a>
DIGITAL Fortran 90 provides the capability for programs to read and write 
unformatted data (originally written using unformatted I/O statements) 
in
<a name="index_x_3029"></a>
several nonnative floating-point formats and in big endian INTEGER or 
floating-point format.

</p><p>
When reading a nonnative unformatted format, the nonnative format on 
disk must be converted to native format in memory. Similarly, native 
data in memory can be written to a nonnative unformatted format. If a 
converted nonnative value is outside the range of the native data type, 
a run-time message appears (listed in <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_033.html#tab_runtime_errors">Table 8-2</a>).

</p><p>
Supported native and nonnative floating-point formats include:

</p><ul>
  <li>Standard IEEE little endian floating-point formats<sup>1</sup> and 
  little endian integers. These formats are found on DIGITAL UNIX (Alpha) 
  systems, DIGITAL OpenVMS Alpha systems, Microsoft® Windows 
  NT<sup>tm</sup> systems, IBM-compatible PC systems, and DIGITAL ULTRIX 
  RISC systems. On DIGITAL UNIX systems, these are the native (in memory) 
  floating-point and integer formats.
<a name="index_x_3030"></a>
<a name="index_x_3031"></a>
<a name="index_x_3032"></a>
<a name="index_x_3033"></a>
  </li><li>Standard IEEE big endian floating-point formats<sup>1</sup> and big 
  endian integers found on most Sun systems, most Hewlett-Packard systems 
  (such as HP-UX systems), and IBM's RISC System/6000 systems.
  </li><li>DIGITAL VAX little endian floating-point formats and little endian 
  integers supported by DIGITAL Fortran for OpenVMS VAX systems and 
  DIGITAL Fortran for OpenVMS Alpha systems.
  </li><li>Big endian proprietary floating-point formats and big endian 
  integers associated with CRAY (CRAY systems).
  </li><li>Big endian proprietary floating-point formats and big endian 
  integers associated with IBM (the IBM's System\370 and similar systems).
</li></ul>

<p>
<a name="index_x_3034"></a>
<a name="index_x_3035"></a>
<a name="index_x_3036"></a>
The native memory format uses little endian integers and little endian 
IEEE floating-point formats, as follows:

</p><ul>
  <li>INTEGER and LOGICAL declarations of one, two, four, or eight bytes 
  (intrinsic kinds 1, 2, 4, and 8). You can specify the integer data 
  length by using an explicit data declaration (kind parameter or size 
  specifier). All INTEGER and LOGICAL declarations without a kind 
  parameter or size specifier will be four bytes in length. To request an 
  8-byte size for all INTEGER and LOGICAL declarations without a kind 
  parameter or size specifier, use an
<font size="+1"><tt>f90</tt></font>
 command-line option (see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_int_options">Section 9.2.1</a>).
  </li><li>IEEE S_float format for single-precision 4-byte REAL and 8-byte 
  COMPLEX declarations (KIND=4). You can specify the real or complex data 
  length by using an explicit data declaration (kind parameter or size 
  specifier). For all REAL or COMPLEX declarations without a kind 
  parameter or size specifier, this is the default size unless you use an
<font size="+1"><tt>f90</tt></font>
 command-line option to request double-precision sizes (see 
 <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_realcomplex_option">Section 9.4.1</a>).
  </li><li>IEEE T_float format for double-precision 8-byte REAL and 16-byte 
  COMPLEX declarations (KIND=8). You can specify the real or complex data 
  length by using an explicit data declaration (kind parameter or size 
  specifier). To request double-precision sizes for all REAL or COMPLEX 
  declarations without a kind parameter or size specifier, you can use an
<font size="+1"><tt>f90</tt></font>
 command-line option (see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_realcomplex_option">Section 9.4.1</a>).
  </li><li>DIGITAL IEEE style X_float format for extended-precision 16-byte 
  REAL declarations (KIND=16). You can specify the real data length by 
  using an explicit data declaration (kind parameter or size specifier). 
  To request extended-precision sizes for all DOUBLE PRECISION 
  declarations, you can use an
<font size="+1"><tt>f90</tt></font>
 command-line option (see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_realcomplex_option">Section 9.4.1</a>).
</li></ul>

<p>
<a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_035.html#tab_nonnative_float">Table 10-1</a> lists the keywords for the supported unformatted file 
data formats. Use the appropriate keyword after the
<font size="+1"><tt>-convert</tt></font>
 option (such as
<font size="+1"><tt>-convert cray</tt></font>
) or as an environment variable value (see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_036.html#sec_nonnative_method">Section 10.4</a>).
<a name="index_x_3037"></a>
<a name="index_x_3038"></a>
<a name="index_x_3039"></a>
<a name="index_x_3040"></a>
<a name="index_x_3041"></a>
<a name="index_x_3042"></a>
<a name="index_x_3043"></a>
</p><p>
<a name="index_x_3044"></a>

<table border="3">
  <caption><a name="tab_nonnative_float"><strong>Table 10-1 Unformatted Numeric Formats, Keywords, and Supported Data Types</strong></a></caption>
  <tbody><tr bgcolor="lightseagreen">
    <th align="center">Recognized Keyword<sup>1</sup> </th>
    <th align="center">Description </th>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      BIG_ENDIAN
    </td>
    <td>
Big endian integer data of the appropriate INTEGER size (one, two, or 
four bytes) and big endian IEEE floating-point formats for REAL and 
COMPLEX single- and double-precision numbers. INTEGER (KIND=1) or 
INTEGER*1 data is the same for little endian and big endian.
<a name="index_x_3045">
</a>
 <a name="index_x_3046">
</a>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      CRAY
    </td>
    <td>
Big endian integer data of the appropriate INTEGER size (one, two, 
four, or eight bytes) and big endian CRAY proprietary floating-point 
format for
<a name="index_x_3047">
</a>
       REAL and COMPLEX single- and double-precision numbers.
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      FDX
    </td>
    <td>
Native little endian integers of the appropriate INTEGER size (one, 
two, four, or eight bytes) and the following little endian DIGITAL 
proprietary floating-point formats:
<ul>
<li>VAX F_float for REAL (KIND=4) and COMPLEX (KIND=4)
<a name="index_x_3048">
</a>
 <a name="index_x_3049">
</a>
 </li><li>VAX D_float for REAL (KIND=8) and COMPLEX (KIND=8)
</li><li>IEEE style X_float for REAL (KIND=16)
</li></ul>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      FGX
    </td>
    <td>
Native little endian integers of the appropriate INTEGER size (one, 
two, four, or eight bytes) and the following little endian DIGITAL 
proprietary floating-point formats:
<ul>
<li>VAX F_float for REAL (KIND=4) and COMPLEX (KIND=4)
<a name="index_x_3050">
</a>
 <a name="index_x_3051">
</a>
 </li><li>VAX G_float for REAL (KIND=8) and COMPLEX (KIND=8)
</li><li>IEEE style X_float for REAL (KIND=16)
</li></ul>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      IBM
    </td>
    <td>
Big endian integer data of the appropriate INTEGER size (one, two, or 
four bytes) and big endian IBM proprietary (System\370 and similar) 
floating-point format for
<a name="index_x_3052">
</a>
       REAL and COMPLEX single- and double-precision numbers.
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      LITTLE_ENDIAN
    </td>
    <td>
Native little endian integers of the appropriate INTEGER size (one, 
two, four, or eight bytes) and the following native little endian IEEE 
floating-point formats:
<ul>
<li>S_float for REAL (KIND=4) and COMPLEX (KIND=4)
<a name="index_x_3053">
</a>
 <a name="index_x_3054">
</a>
 </li><li>T_float for REAL (KIND=8) and COMPLEX (KIND=8)
</li><li>IEEE style X_float for REAL (KIND=16)
</li></ul>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      NATIVE
    </td>
    <td>
      No conversion occurs between memory and disk. This is the default for 
      unformatted files.
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      VAXD
    </td>
    <td>
Native little endian integers of the appropriate INTEGER size (one, 
two, four, or eight bytes) and the following little endian VAX DIGITAL 
proprietary floating-point formats:
<ul>
<li>VAX F_float for REAL (KIND=4) and COMPLEX (KIND=4)
<a name="index_x_3055">
</a>
 <a name="index_x_3056">
</a>
 </li><li>VAX D_float for REAL (KIND=8) and COMPLEX (KIND=8)
</li><li>VAX H_float for REAL (KIND=16)
</li></ul>
    </td>
  </tr>
  <tr bgcolor="blanchedalmond">
    <td>
      VAXG
    </td>
    <td>
Native little endian integers of the appropriate INTEGER size (one, 
two, four, or eight bytes) and the following little endian VAX DIGITAL 
proprietary floating-point formats:
<ul>
<li>VAX F_float for REAL (KIND=4) and COMPLEX (KIND=4)
<a name="index_x_3057">
</a>
 <a name="index_x_3058">
</a>
 </li><li>VAX G_float for REAL (KIND=8) and COMPLEX (KIND=8)
</li><li>VAX H_float for REAL (KIND=16)
</li></ul>
    </td>
  </tr>
</tbody></table>
</p><hr>
<sup>1</sup>When using the data type as a <font size="+1"><tt>-convert</tt></font> keyword option on the <font size="+1"><tt>f90</tt></font> command line, the data type keyword must be 
in lowercase, such as <font size="+1"><tt>-convert big_endian</tt></font>.
<br>
<hr>

<p>
While this solution is not expected to fulfill all floating-point 
conversion needs, it provides the capability to read and write various 
types of unformatted nonnative floating-point data.
</p><p>
<strong>For More Information:</strong>
<br>

</p><ul>
  <li>On porting OpenVMS Fortran data files to a DIGITAL UNIX system for 
  use by DIGITAL Fortran 90, see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_044.html#sec_compat_vms">Section A.4</a>.
  </li><li>Ranges and the format of native IEEE floating-point data types, see 
  <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#tab_datatype_summ">Table 9-1</a> and <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_fltng_pt">Section 9.4</a>.
  </li><li>Ranges and the format of VAX floating-point data types, see 
  <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_044.html#sec_fltng_pt_vax">Section A.4.3</a>.
  </li><li>Specifying the size of INTEGER declarations (without a kind) using 
  an
<font size="+1"><tt>f90</tt></font>
 command option, see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_int_options">Section 9.2.1</a>.
  </li><li>Specifying the size of LOGICAL declarations (without a kind) using 
  an
<font size="+1"><tt>f90</tt></font>
 command option, see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_logical_rep">Section 9.3</a>.
  </li><li>Specifying the size of REAL or COMPLEX declarations (without a 
  kind) using an
<font size="+1"><tt>f90</tt></font>
 command option, see <a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#sec_realcomplex_option">Section 9.4.1</a>.
  </li><li>Data declarations and other DIGITAL Fortran 90 language information, 
  see the <em>DIGITAL Fortran Language Reference Manual</em>.
</li></ul>

<p>
</p><center>
<table bgcolor="lightskyblue" border="0" width="75%">
  <tbody><tr>
    <td>
      <center><font color="black" size="+2"><strong>Note </strong></font></center>
        <hr noshade="noshade" size="1">
        <font color="black">
        <h4><strong><sup>1</sup> </strong> IEEE floating-point formats are 
        defined in the IEEE Standard for Binary Floating-Point Arithmetic, 
        ANSI/IEEE Standard 754-1985, Institute of Electrical and Electronics 
        Engineers, August 1985.</h4>
    </font>
    </td>
  </tr>
</tbody></table>
</center>
<p>

<a name="bottom_035"></a>
</p><p>
</p><hr>
<table border="2">
  <tbody><tr>
    <td align="center" bgcolor="lightgoldenrodyellow" width="100"><a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_034.html#bottom_034">Previous</a>
    </td><td align="center" bgcolor="aquamarine" width="100"><a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_036.html">Next</a>
    </td><td align="center" bgcolor="cyan" width="100"><a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_contents.html">Contents</a>
    </td><td align="center" bgcolor="lightskyblue" width="100"><a href="http://www.hpc.unimelb.edu.au/doc/f90lrm/dfum_index.html">Index</a>
</td></tr></tbody></table>


</body></html>