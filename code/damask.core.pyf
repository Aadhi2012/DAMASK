! $Id$
!    -*- f90 -*-
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Note: the syntax of this file is case sensitive.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This file was auto-generated with f2py (version:2_5972).
! See http://cens.ioc.ee/projects/f2py2e/
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! The auto-generated file is quite heavily corrected
! For modifying, notice the following hints:
!   - if the dimension of an array depend on a array that is itself an input, use the C-Syntax: (1) becomes [0] etc.
!   - be sure that the precision defined for math.f90 is integer, real*8, and complex*16
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
python module core ! in 
   interface  ! in :core


     module damask_interface ! in :damask_interface:DAMASK_spectral_interface.f90

        subroutine damask_interface_init(loadcaseParameterIn,geometryParameterIn) ! in :damask_interface:DAMASK_spectral_interface.f90
            character(len=1024), intent(in)   :: loadcaseParameterIn                                      
            character(len=1024), intent(in)   :: geometryParameterIn
        end subroutine damask_interface_init            

      end module damask_interface


      module math ! in :math:math.f90

        subroutine volume_compare(res,geomdim,defgrad,nodes,volume_mismatch) ! in  :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                  :: res
            real*8,  dimension(3),                             intent(in)                  :: geomdim
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            real*8,  dimension(res[0]+1,res[1]+1,res[2]+1,3),  intent(in),  depend(res[0],res[1],res[2])    :: nodes
            ! output variables
            real*8, dimension(res[0],   res[1],  res[2]),      intent(out), depend(res[0],res[1],res[2]))   :: volume_mismatch
        end subroutine volume_compare

        subroutine shape_compare(res,geomdim,defgrad,nodes,centroids,shape_mismatch) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                  :: res
            real*8,  dimension(3),                             intent(in)                  :: geomdim
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            real*8,  dimension(res[0]+1,res[1]+1,res[2]+1,3),  intent(in),  depend(res[0],res[1],res[2])    :: nodes
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(in),  depend(res[0],res[1],res[2])    :: centroids
            ! output variables
            real*8, dimension(res[0],   res[1],  res[2]),      intent(out), depend(res[0],res[1],res[2]))   :: shape_mismatch
        end subroutine shape_compare

        subroutine mesh_regular_grid(res,geomdim,defgrad_av,centroids,nodes) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                  :: res
            real*8,  dimension(3),                             intent(in)                  :: geomdim
            real*8,  dimension(3,3),                           intent(in)                  :: defgrad_av
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(in),  depend(res[0],res[1],res[2])    :: centroids
            ! output variables
            real*8,  dimension(res[0]+1,res[1]+1,res[2]+1,3),  intent(out), depend(res[0],res[1],res[2])    :: nodes
            ! variables with dimension depending on input
            real*8,  dimension(res[0]+2,res[1]+2,res[2]+2,3),               depend(res[0],res[1],res[2])    :: wrappedCentroids
        end subroutine mesh_regular_grid

        subroutine deformed_linear(res,geomdim,defgrad_av,defgrad,coord_avgCorner) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                                   :: res
            real*8,  dimension(3),                             intent(in)                                   :: geomdim
            real*8,  dimension(3,3),                           intent(in)                                   :: defgrad_av
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            ! output variables
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(out), depend(res[0],res[1],res[2])    :: coord_avgCorner
            ! variables with dimension depending on input
            real*8,  dimension(8,6,res[0],res[1],res[2],3),                 depend(res[0],res[1],res[2])    :: coord
            real*8,  dimension(8,res[0],res[1],res[2],3),                   depend(res[0],res[1],res[2])    :: coord_avgOrder
        end subroutine deformed_linear

        subroutine deformed_fft(res,geomdim,defgrad_av,scaling,defgrad,coords) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                                   :: res
            real*8,  dimension(3),                             intent(in)                                   :: geomdim
            real*8,  dimension(3,3),                           intent(in)                                   :: defgrad_av
            real*8,                                            intent(in)                                   :: scaling
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            ! output variables
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(out), depend(res[0],res[1],res[2])    :: coords
        end subroutine deformed_fft

        subroutine curl_fft(res,geomdim,vec_tens,field,curl) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                                     intent(in)                                          :: res
            real*8,  dimension(3),                                     intent(in)                                          :: geomdim
            integer,                                                   intent(in)                                          :: vec_tens
            real*8,  dimension(res[0],  res[1],  res[2],  vec_tens,3), intent(in),  depend(res[0],res[1],res[2],vec_tens)  :: field
            ! output variables
            real*8,  dimension(res[0],  res[1],  res[2],  vec_tens,3), intent(out), depend(res[0],res[1],res[2],vec_tens)  :: curl
            ! variables with dimension depending on input
            real*8,     dimension(res[0]/2+1,res[1],res[2],3),                      depend(res[0],res[1],res[2])           :: xi
        end subroutine curl_fft

        subroutine divergence_fft(res,geomdim,vec_tens,field,divergence) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                                     intent(in)                                          :: res
            real*8,  dimension(3),                                     intent(in)                                          :: geomdim
            integer,                                                   intent(in)                                          :: vec_tens
            real*8,  dimension(res[0],  res[1],  res[2],  vec_tens,3), intent(in),  depend(res[0],res[1],res[2],vec_tens)  :: field
            ! output variables
            real*8,  dimension(res[0],  res[1],  res[2],  vec_tens),   intent(out), depend(res[0],res[1],res[2],vec_tens)  :: divergence
            ! variables with dimension depending on input   
            real*8,     dimension(res[0]/2+1,res[1],res[2],3),                      depend(res[0],res[1],res[2],3)         :: xi       
        end subroutine divergence_fft

        subroutine divergence_fdm(res,geomdim,vec_tens,order,field,divergence) ! in :math:math.f90
            ! input variables
            integer dimension(3),                                     intent(in)                                          :: res
            real*8  dimension(3),                                     intent(in)                                          :: geomdim
            integer                                                   intent(in)                                          :: vec_tens
            integer,                                                  intent(in)                                          :: order
            real*8  dimension(res[0],  res[1],  res[2],  vec_tens,3), intent(in),  depend(res[0],res[1],res[2],vec_tens)  :: field
            ! output variables
            real*8  dimension(res[0],  res[1],  res[2],  vec_tens),   intent(out), depend(res[0],res[1],res[2],vec_tens)  :: divergence
        end subroutine divergence_fdm

        subroutine tensor_avg(res,tensor,avg) ! in :math:math.f90
            ! input variables
            integer dimension(3),                             intent(in)                                   :: res
            real*8  dimension(res[0],res[1],res[2],3,3),      intent(in),  depend(res[0],res[1],res[2])  :: tensor
            ! output variables
            real*8 dimension(3,3),                            intent(out)                                  :: avg
        end subroutine tensor_avg

        subroutine logstrain_mat(res,defgrad,logstrain_field) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                                     intent(in)                                          :: res
            real*8, dimension(res[0],res[1],res[2],3,3),       intent(in),     depend(res[0],res[1],res[2]) :: defgrad
            ! output variables
            real*8, dimension(res[0],res[1],res[2],3,3),       intent(out),    depend(res[0],res[1],res[2]) :: logstrain_field            
        end subroutine logstrain_mat

        subroutine logstrain_spat(res,defgrad,logstrain_field) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                                     intent(in)                                          :: res
            real*8, dimension(res[0],res[1],res[2],3,3),       intent(in),     depend(res[0],res[1],res[2]) :: defgrad
            ! output variables
            real*8, dimension(res[0],res[1],res[2],3,3),       intent(out),    depend(res[0],res[1],res[2]) :: logstrain_field            
        end subroutine logstrain_spat

        subroutine calculate_cauchy(res,defgrad,p_stress,c_stress) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                                     intent(in)                                          :: res
            real*8, dimension(res[0],res[1],res[2],3,3),       intent(in),     depend(res[0],res[1],res[2]) :: defgrad
            real*8, dimension(res[0],res[1],res[2],3,3),       intent(in),     depend(res[0],res[1],res[2]) :: p_stress
            ! output variables
            real*8, dimension(res[0],res[1],res[2],3,3),       intent(out),    depend(res[0],res[1],res[2]) :: c_stress  
        end subroutine calculate_cauchy

        subroutine math_equivStrain33_field(res,tensor,vm) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                                     intent(in)                                          :: res
            real*8, dimension(res[0],res[1],res[2],3,3),intent(in),depend(res[0],res[1],res[2]) :: tensor
            ! output variables
            real*8, dimension(res[0],res[1],res[2]),intent(out),depend(res[0],res[1],res[2]) :: vm
        end subroutine math_equivStrain33_field
        
        subroutine math_nearestNeighborSearch(res_new,res_old,defgrad_av,geomdim,deformed_set,result_indices) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                                  intent(in)                                           :: res_new
            integer, dimension(3),                                  intent(in)                                           :: res_old
            real, dimension(3,3),                                   intent(in)                                           :: defgrad_av
            real, dimension(3),                                     intent(in)                                           :: geomdim
            real, dimension(res_old[0],res_old[1],res_old[2],3),    intent(in), depend(res_old[0],res_old[1],res_old[2]) :: deformed_set
           ! output variables
           integer, dimension(res_new[0]*res_new[1]*res_new[2]),    intent(out), depend(res_new[0],res_new[1],res_new[2]):: result_indices
        end subroutine math_nearestNeighborSearch
     end module math

     module mesh ! in :mesh:mesh.f90

        subroutine mesh_regrid(resNew) ! in :mesh:mesh.f90
            integer, dimension(3), intent(in,out), optional      :: resNew
        end subroutine mesh_regrid            

     end module mesh
      
   end interface 
end python module core

