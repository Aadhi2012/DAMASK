! $Id$
!    -*- f90 -*-
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Note: the syntax of this file is case sensitive.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! This file was auto-generated with f2py (version:2_5972).
! See http://cens.ioc.ee/projects/f2py2e/
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! The auto-generated file is quite heavily corrected
! For modifying, notice the following hints:
!   - if the dimension of an array depend on a array that is itself an input, use the C-Syntax: (1) becomes [0] etc.
!   - be sure that the precision defined for math.f90 is integer, real*8, and complex*16
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
python module core ! in 
   interface  ! in :core

     module prec
        subroutine prec_init
        end subroutine prec_init
     end module prec

     module damask_interface ! in :damask_interface:DAMASK_spectral_interface.f90
        subroutine DAMASK_interface_init(loadcaseParameterIn,geometryParameterIn) ! in :damask_interface:DAMASK_spectral_interface.f90
            character(len=1024), intent(in)   :: loadcaseParameterIn                                      
            character(len=1024), intent(in)   :: geometryParameterIn
        end subroutine DAMASK_interface_init            
     end module damask_interface

     module io
        subroutine IO_init
        end subroutine IO_init
     end module io
     
     module numerics
        subroutine numerics_init
        end subroutine numerics_init
     end module numerics

     module debug
        subroutine debug_init
        end subroutine debug_init
     end module debug

     module math ! in :math:math.f90
        subroutine math_init
        end subroutine math_init

        function math_curlFFT(geomdim,field) ! in :math:math.f90
            ! input variables
            real*8,  dimension(3),                                     intent(in)                                          :: geomdim
            real*8,  dimension(:,:,:,:,:),                             intent(in),                                         :: field
            ! function definition
            real*8,  dimension(size(field,1),size(field,2),size(field,3),size(field,4),size(field,5)),      depend(field)  :: math_curlFFT
            ! variables with dimension depending on input
            real*8,     dimension(size(field,1)/2+1,size(field,2),size(field,3),3),                         depend(field)  :: xi
        end function math_curlFFT 

        function math_divergenceFFT(geomdim,field) ! in :math:math.f90
            ! input variables
            real*8,  dimension(3),                                     intent(in)                                          :: geomdim
            real*8,  dimension(:,:,:,:,:),                             intent(in),                                         :: field
            ! function definition
            real*8,  dimension(size(field,1),size(field,2),size(field,3),size(field,4)),                    depend(field)  :: math_divergenceFFT
            ! variables with dimension depending on input   
            real*8,     dimension(size(field,1)/2+1,size(field,2),size(field,3),3),                         depend(field)  :: xi
        end function math_divergenceFFT

        function math_divergenceFDM(geomdim,order,field) ! in :math:math.f90
            ! input variables
            real*8  dimension(3),                                     intent(in)                                          :: geomdim
            integer,                                                  intent(in)                                          :: order
            real*8,  dimension(:,:,:,:,:),                            intent(in),                                         :: field
            ! function definition
            real*8,  dimension(size(field,1),size(field,2),size(field,3),size(field,4)),                   depend(field)  :: math_divergenceFDM
        end function math_divergenceFDM
        
        subroutine math_nearestNeighborSearch(spatialDim,Favg,geomdim,queryPoints,domainPoints,querySet,domainSet,indices) ! in :math:math.f90
             ! input variables
             integer,                                           intent(in) :: spatialDim
             real*8,  dimension(3,3),                           intent(in) :: Favg
             real*8,  dimension(3),                             intent(in) :: geomdim
             integer,                                           intent(in) :: queryPoints
             integer,                                           intent(in) :: domainPoints
             real*8,  dimension(spatialDim,queryPoints),        intent(in),  depend(spatialDim,queryPoints)  :: querySet
             real*8,  dimension(spatialDim,domainPoints),       intent(in),  depend(spatialDim,domainPoints) :: domainSet
             ! output variable
             integer, dimension(queryPoints),                   intent(out), depend(queryPoints)             :: indices
             ! depending on input
             real*8,   dimension(spatialDim,(3**spatialDim)*domainPoints), depend(spatialDim,domainPoints)   :: domainSetLarge
        end subroutine math_nearestNeighborSearch
        
        function math_tensorAvg(field) ! in :math:math.f90
            ! input variables
            real*8  dimension(:,:,:,:,:),                    intent(in),                                     :: field
            ! function definition
            real*8 dimension(3,3),                                                                           :: math_tensorAvg
        end function math_tensorAvg

        function math_logstrainSpat(F) ! in :math:math.f90
            ! input variables
            real*8, dimension(:,:,:,:,:),       intent(in)                                                   :: F
            ! output variables
            real*8,  dimension(size(F,1),size(F,2),size(F,3),3,3),             depend(F)                     :: math_logstrainSpat            
        end function math_logstrainSpat

        function math_logstrainMat(F) ! in :math:math.f90
            ! input variables
            real*8, dimension(:,:,:,:,:),       intent(in)                                                   :: F
            ! function
            real*8,  dimension(size(F,1),size(F,2),size(F,3),3,3),             depend(F)                     :: math_logstrainMat            
        end function math_logstrainMat

        function math_cauchy(F,P) ! in :math:math.f90
            ! input variables
            real*8, dimension(:,:,:,:,:),       intent(in)                                                   :: F
            real*8, dimension(:,:,:,:,:),       intent(in)                                                   :: P
            ! function
            real*8,  dimension(size(F,1),size(F,2),size(F,3),3,3),             depend(F)                     :: math_cauchy  
        end function math_cauchy
        
     end module math

     module fesolving
        subroutine FE_init
        end subroutine FE_init 
     end module fesolving

     module mesh ! in :mesh:mesh.f90
	      subroutine mesh_init(ip,element)
 			       integer, parameter                   ::      ip = 1
             integer, parameter                   :: element = 1
        end subroutine mesh_init
		
        function mesh_regrid(adaptive,resNewInput,minRes) ! in :mesh:mesh.f90
             logical, intent(in)                                  :: adaptive
             integer, dimension(3)                                :: mesh_regrid
             integer, dimension(3), intent(in), optional          :: resNewInput = -1
             integer, dimension(3), intent(in), optional          :: minRes = -1
        end function mesh_regrid   
        
        subroutine mesh_regular_grid(res,geomdim,defgrad_av,centroids,nodes) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                  :: res
            real*8,  dimension(3),                             intent(in)                  :: geomdim
            real*8,  dimension(3,3),                           intent(in)                  :: defgrad_av
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(in),  depend(res[0],res[1],res[2])    :: centroids
            ! output variables
            real*8,  dimension(res[0]+1,res[1]+1,res[2]+1,3),  intent(out), depend(res[0],res[1],res[2])    :: nodes
            ! variables with dimension depending on input
            real*8,  dimension(res[0]+2,res[1]+2,res[2]+2,3),               depend(res[0],res[1],res[2])    :: wrappedCentroids
        end subroutine mesh_regular_grid

        subroutine deformed_linear(res,geomdim,defgrad_av,defgrad,coord_avgCorner) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                                   :: res
            real*8,  dimension(3),                             intent(in)                                   :: geomdim
            real*8,  dimension(3,3),                           intent(in)                                   :: defgrad_av
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            ! output variables
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(out), depend(res[0],res[1],res[2])    :: coord_avgCorner
            ! variables with dimension depending on input
            real*8,  dimension(8,6,res[0],res[1],res[2],3),                 depend(res[0],res[1],res[2])    :: coord
            real*8,  dimension(8,res[0],res[1],res[2],3),                   depend(res[0],res[1],res[2])    :: coord_avgOrder
        end subroutine deformed_linear

        subroutine deformed_fft(res,geomdim,defgrad_av,scaling,defgrad,coords) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                                   :: res
            real*8,  dimension(3),                             intent(in)                                   :: geomdim
            real*8,  dimension(3,3),                           intent(in)                                   :: defgrad_av
            real*8,                                            intent(in)                                   :: scaling
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            ! output variables
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(out), depend(res[0],res[1],res[2])    :: coords
        end subroutine deformed_fft
        
        subroutine volume_compare(res,geomdim,defgrad,nodes,volume_mismatch) ! in  :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                  :: res
            real*8,  dimension(3),                             intent(in)                  :: geomdim
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            real*8,  dimension(res[0]+1,res[1]+1,res[2]+1,3),  intent(in),  depend(res[0],res[1],res[2])    :: nodes
            ! output variables
            real*8, dimension(res[0],   res[1],  res[2]),      intent(out), depend(res[0],res[1],res[2]))   :: volume_mismatch
        end subroutine volume_compare

        subroutine shape_compare(res,geomdim,defgrad,nodes,centroids,shape_mismatch) ! in :math:math.f90
            ! input variables
            integer, dimension(3),                             intent(in)                  :: res
            real*8,  dimension(3),                             intent(in)                  :: geomdim
            real*8,  dimension(res[0],  res[1],  res[2],  3,3),intent(in),  depend(res[0],res[1],res[2])    :: defgrad
            real*8,  dimension(res[0]+1,res[1]+1,res[2]+1,3),  intent(in),  depend(res[0],res[1],res[2])    :: nodes
            real*8,  dimension(res[0],  res[1],  res[2],  3),  intent(in),  depend(res[0],res[1],res[2])    :: centroids
            ! output variables
            real*8, dimension(res[0],   res[1],  res[2]),      intent(out), depend(res[0],res[1],res[2]))   :: shape_mismatch
        end subroutine shape_compare
        
     end module mesh
   end interface 
end python module core

